"""This module accepts spam file name as parameter and returns all parsed fields as items of a dictionary
In current state, it's accepting spam file name as parameter, parsing all fields, saving in a dictionary and forwarding to another module

"""

import email.Message
import email.Parser
from email.header import decode_header
import os
import sys
import logging
import re
import time
import datetime
import hashlib
import base64

import MySQLdb as mdb
import ssdeep
import lxml.html

import shivadecide
import shivalinkparser
import shivaconfig

# Global dictionary to store parsed fields of spam
mailFields = {'headers':'', 'to':'', 'from':'', 'subject':'', 'date':'', 'firstSeen':'', 'lastSeen':'', 'firstRelayed':'', 'lastRelayed':'', 'sourceIP':'', 'sensorID':'', 'text':'', 'html':'', 'inlineFileName':[], 'inlineFile':[], 'inlineFileMd5':[], 'attachmentFileName':[], 'attachmentFile':[], 'attachmentFileMd5':[], 'links':[], 'spam_id':'', 'spamMd5':'', 'len':''}

randomText = """@Deprecation
In Solr 1.3, many classes were moved around. Although classes compiled against 1.2 will run in 1.3, updating class references is recommended.
Specifically: many classes from org.apache.util moved to org.apache.common.util many classes from org.apache.solr.request moved to org.apache.solr.common.params org.apache.solr.request.StandardRequestHandler moved to org.apache.solr.handler.StandardRequestHandler and is a subclass of org.apache.solr.handler.SearchHandler
org.apache.solr.request.DisMaxRequestHandler moved to org.apache.solr.handler.DisMaxRequestHandler and deprecated in favor of adding 'defType=dismax' to StandardRequestHandler init params
Solr1.3 (last edited 2009-09-20 22:04:51 by localhost SHIVA."""

def md5checksum(filepath):
    m = hashlib.md5()
    m.update(filepath)
    return m.hexdigest()



def getfuzzyhash():
    """Returns fuzzy hash of spam.
    This function returns hash generated using the ssdeep library.
    Hash is generated using the combination of mail's body + subject.
    Msg length is being checked because SSDEEP has some issues with comparing hashes
    of small spams. If spam's body is very less or non existent, we add our randomText to body.
    """
    if mailFields['html']:
        if len(mailFields['html']) < 60:
            data = mailFields['html'] + " " + mailFields['subject'] + randomText
            logging.info("Data is %s" % data)
        else:
            data = mailFields['html'] + " " + mailFields['subject']
    else:
        if len(mailFields['text']) < 60:
            data = mailFields['text'] + " " + mailFields['subject'] + randomText
            logging.info("Data is %s" % data)
        else:
            data = mailFields['text'] + " " + mailFields['subject']

    mailFields['len'] = len(data)
    return ssdeep.hash(data)



def fix_padding_for_attachments(payload):
    logging.critical("\t[+]Fixing Padding for Attachment if needed")
    logging.critical("\t\t[+]length of original payload: %s" % len(payload))

    payload = payload.rstrip()
    logging.critical("\t\t[+]length after striping whitespaces: %s" % len(payload))

    missing_padding = (4 - len(payload) % 4) % 4
    logging.critical("\t\t[+]missing padding: %s" % missing_padding)
    payload += '=' * missing_padding

    logging.critical("\t\t[+]New length after padding: %s" % len(payload))
    return payload



def writepartsrecurse(msg):
    """
    This module recursively parses all fields of multipart spam mail
    """
    while isinstance(msg.get_payload(),email.Message.Message):
        msg=msg.get_payload()

    if msg.is_multipart():
        for subMsg in msg.get_payload():
            writepartsrecurse(subMsg)

    else:
        content=msg.get_content_type()
        logging.critical("\t[+]Content type::::: %s" % content)

        logging.critical("\t[+]File name before decoding: %s" % msg.get_filename())
        file_name, encoding = decode_header(msg.get_filename())[0]                                  # Seen cases of unicode. Function returns the encoding type if any

        file_name = file_name.replace("'", "")
        if encoding == None:
            fileName = file_name
        else:
            fileName = file_name.decode(encoding)
            fileName = fileName.encode('utf-8')

        logging.critical("\t[+]File name after decoding: %s" % fileName)

        if msg.get_content_type() == 'text/plain' and msg['Content-Disposition'] == None:                   # value of content-dispostion is None in this case
            mailFields['text'] = msg.get_payload(decode=True)                                                 # decode says - if in base64, decode the value

        elif msg.get_content_type() == 'text/html':                                                         # value of content-dispostion is None in this case
            mailFields['html'] = msg.get_payload(decode=True)

        elif msg['Content-Disposition'] != None and msg['Content-Disposition'].find('inline;') >= 0:        # if 'inline' file found
            logging.critical("Inside inline handling")
            payload = fix_padding_for_attachments(msg.get_payload())

            mailFields['attachmentFile'].append(payload)
            mailFields['attachmentFileName'].append(fileName)
            mailFields['attachmentFileMd5'].append(md5checksum((payload).decode('base64')))

        elif msg['Content-Disposition'] != None and msg['Content-Disposition'].find('attachment;') >= 0:    # if attachment found
            logging.critical("Inside Attachment handling")
            payload = fix_padding_for_attachments(msg.get_payload())

            mailFields['attachmentFile'].append(payload)
            mailFields['attachmentFileName'].append(fileName)
            mailFields['attachmentFileMd5'].append(md5checksum((payload).decode('base64')))

        elif msg.get_filename() != None:                                                                                    ## Sometimes field "Content-Disposition" is missing, field "attachment" is missing but "file name" is there with binary content
            payload = fix_padding_for_attachments(msg.get_payload())
            mailFields['attachmentFile'].append(payload)
            mailFields['attachmentFileName'].append(fileName)
            mailFields['attachmentFileMd5'].append(md5checksum((payload).decode('base64')))

        else:
            logging.critical("[-] - (Module ShivaParser.py) No match for text/html/content_type or Content-Disposition -")

    return None


def main(key, msgMailRequest, exeSql):
    """
    This function gets called from queueFilter.filter()
    """
    logging.critical("inside main module")
    global mailFields

    mailFields = {'headers':'', 'to':'', 'from':'', 'subject':'', 'date':'', 'firstSeen':'', 'lastSeen':'', 'firstRelayed':'', 'lastRelayed':'', 'sourceIP':'', 'sensorID':'', 'text':'', 'html':'', 'inlineFileName':[], 'inlineFile':[], 'inlineFileMd5':[], 'attachmentFileName':[], 'attachmentFile':[], 'attachmentFileMd5':[], 'links':[], 'spam_id':'', 'len':'', 'spamMd5':''}
  
    mailFile=open(shivaconfig.queuePath + key,"rb")
    p=email.Parser.Parser()
    msg=p.parse(mailFile)
    mailFile.close()

    f = open(shivaconfig.queuePath + key)
    msgmsg = email.message_from_file(f)
    pp = email.parser.HeaderParser()
    hh = pp.parsestr(msgmsg.as_string())

    headerString = ''
    for h in hh.items():
        headerString += str(h) + '\n'

    mailFields['headers'] = headerString
    mailFields['headers'] = str(mailFields['headers']).replace("'", "")

    try:
        try:
            logging.critical("msg['to']: %s", msg['to'])
            if msg['to'] != None:
                mailFields['to'] = msg['to'].replace("'", "")
            else:
                logging.critical("[-] Info shivamailparser.py - To field has value None")
                mailFields['to'] = "-"

        except Exception, e:
            logging.critical("[-] Error (Module shivamailparser.py) - some issue in parsing 'to' field %s" % key)
            logging.critical("to: %s", msg['to'])
            shivaconfig.errorhandling(key, msgMailRequest, "[-] Error (Module shivamailparser.py) - some issue in parsing 'to' field %s %s \n" % (key, e))
            return None

        try:
            from_field = msg['from']
            logging.critical("From field before decoding: %s" % from_field)
            from_field, encoding = decode_header(msg.get('from'))[0]
            logging.critical("from: %s encoding: %s" % (from_field, encoding))

            if from_field != None:
                if encoding == None:
                    mailFields['from'] = from_field
                    mailFields['from'] = mailFields['from'].replace("'", "")
                    mailFields['from'] = mailFields['from'].replace('"', '')
                    logging.critical("From Field had no encoding: %s" % mailFields['from'])

                else:
                    try:
                        logging.critical("From Field is Encoded")
                        regex_from = r'''([\w\-\.+]+@\w[\w\-]+\.+[\w\-]+)'''
                        mailFields['from'] = re.findall (re.compile(regex_from), msg['from'])[0]

                        mailFields['from'] = mailFields['from'].replace("'", "")
                        mailFields['from'] = mailFields['from'].replace('"', '')
                        logging.critical("From Field had encoding: %s" % mailFields['from'])

                    except Exception, e:
                        mailFields['from'] = from_field
                        mailFields['from'] = mailFields['from'].replace("'", "")
                        mailFields['from'] = mailFields['from'].replace('"', '')
                        logging.critical("[-] Warning: From Field had encoding, but regex got issue parsing it - pushing following into DB: %s" % mailFields['from'])
                        shivaconfig.errorhandling(key, msgMailRequest, "[-] Warning (Module shivamailparser.py) 'From' Field had encoding, but regex got issue parsing it %s %s \n" % (key, e))

            else:
                logging.critical("[-] Info shivamailparser.py - From field has value None")
                mailFields['from'] = "-"

        except Exception, e:
            logging.critical("[-] Error (Module shivamailparser.py) - some issue in parsing 'from' field %s -- %s" % (key, e.args))
            logging.critical("from: %s", msg['from'])
            shivaconfig.errorhandling(key, msgMailRequest, "[-] Error (Module shivamailparser.py) - some issue in parsing 'from' field %s %s \n" % (key, e))
            return None

        try:
            subject, encoding = decode_header(msg.get('subject'))[0]                                                                  # Seen cases of unicode. Function returns the encoding type if any

            if encoding == None:
                mailFields['subject'] = subject
                pass
            else:
                mailFields['subject'] = subject.decode(encoding)
                mailFields['subject'] = mailFields['subject'].encode('utf-8')                                                           # Need to encode('utf-8') else won't be able to push into DB

            if mailFields['subject'] != None:
                mailFields['subject'] = mailFields['subject'].replace("'", "")
                mailFields['subject'] = mailFields['subject'].replace('"', '')

            else:
                logging.critical("[-] Info shivamailparser.py - Subject field has value None")
                pass

        except Exception, e:
            logging.critical("[-] Error (Module shivamailparser.py) - some issue in parsing 'subject' field %s" % key)
            logging.critical("subject: %s", mailFields['subject'])
            shivaconfig.errorhandling(key, msgMailRequest, "[-] Error (Module shivamailparser.py) - some issue in parsing 'subject' field %s %s \n" % (key, e))
            return None

        try:
            mailFields['sourceIP'] = key.split("-")[-2]
            mailFields['sensorID'] = key.split("-")[-1]

        except Exception, e:
            logging.critical("[-] Error (Module shivamailparser.py) - some issue in parsing 'sourceIP and sensorID' field %s" % key)
            shivaconfig.errorhandling(key, msgMailRequest, "[-] Error (Module shivamailparser.py) - some issue in parsing 'sourceIP and sensorID' fields %s %s \n" % (key, e))
            return None

        try:
            writepartsrecurse(msg)

        except Exception, e:
            logging.critical("[-] Error (Module shivamailparser.py) - some issue in writePartsRecurse function %s -- %s" % (key, e.args))
            shivaconfig.errorhandling(key, msgMailRequest, "[-] Error (Module shivamailparser.py) - some issue in writePartsRecurse function %s %s \n" % (key, e))
            return None

        try:
            if mailFields['text'] != None:
                mailFields['text'] = mailFields['text'].replace("'", "")

            if mailFields['html'] != None:
                mailFields['html'] = mailFields['html'].replace("'", "")

        except Exception, e:
            logging.critical("[-] Error (Module shivamailparser.py) - some issue in 'text' and 'html' field %s" % key)
            logging.critical("text: %s", mailFields['text'])
            logging.critical("html: %s", mailFields['html'])
            shivaconfig.errorhandling(key, msgMailRequest, "[-] Error (Module shivamailparser.py) - some issue in 'text' and 'html' field %s %s \n" % (key, e))
            return None

        # parse different parts of spam (text, html, inline) and hunt for URLs
        try:
            mailFields['links'] = shivalinkparser.parser(mailFields['html'])
            mailFields['links'].extend(shivalinkparser.parser(mailFields['text']))

        except Exception, e:
            logging.critical("[-] Error (Module shivamailparser.py) - some issue in parsing 'links' field %s" % key)
            logging.critical("links: %s", mailFields['links'])
            shivaconfig.errorhandling(key, msgMailRequest, "[-] Error (Module shivamailparser.py) - some issue in parsing 'links' field %s %s \n" % (key, e))
            return None

        # Timestamping when spam is parsed by our code; not the original time stamping
        mailFields['date'] =  datetime.date.today()
        mailFields['firstSeen'] =  datetime.datetime.now()
        mailFields['lastSeen'] =  datetime.datetime.now()
        mailFields['firstRelayed'] =  datetime.datetime.now()
        mailFields['lastRelayed'] =  datetime.datetime.now()

        try:
            mailFields['spam_id'] = getfuzzyhash()
            logging.info("Spam ID is %s", mailFields["spam_id"])

        except Exception, e:
            logging.critical("[-]Error (Module shivamailparser.py) - occured while calculating fuzzy hash for spam id. Exception is %s", e)

        # Calculating md5 of spam which further will be used as unique identifier for a spam.
        if mailFields['html']:
            mailFields['spamMd5'] = md5checksum(mailFields['subject'] + mailFields['html'])
        elif mailFields['text']:
            mailFields['spamMd5'] = md5checksum(mailFields['subject'] + mailFields['text'])
        else:
            mailFields['spamMd5'] = md5checksum(mailFields['subject'])

    except Exception, e:
        logging.critical("[-] Error (Module shivamailparser.py) - some issue in parsing file %s exception is: %s" % (key, e))
        shivaconfig.errorhandling(key, msgMailRequest, "[-] Error (Module shivamailparser.py) - some issue in parsing file %s %s \n" % (key, e))
        return None


    shivadecide.decide(mailFields, key, exeSql, msgMailRequest)

    return None
