#!/usr/bin/env python
"""
This module accepts spam file name as parameter and returns all parsed fields as items of a dictionary
In current state, it's accepting spam file name as parameter, parsing all fields, saving in a dictionary and forwarding to another module

"""

import email.Message
import email.Parser
from email.header import decode_header
import os, sys, logging, re
import MySQLdb as mdb
import ShivaLinkParser, ShivaMailRelayer, ShivaConfig
import time, datetime
import hashlib								# Shiva - to calculate the md5 of attachment and inline files

# Global dictionary to store parsed fields of spam
mailFields = {'headers':'', 'to':'', 'from':'', 'subject':'', 'date':'', 'firstSeen':'', 'lastSeen':'', 'firstRelayed':'', 'lastRelayed':'', 'sourceIP':'', 'sensorID':'', 'text':'', 'html':'', 'inlineFileName':[], 'inlineFile':[], 'inlineFileMd5':[], 'attachmentFileName':[], 'attachmentFile':[], 'attachmentFileMd5':[], 'links':[], 'spam_id':''}


def md5Checksum(filepath):
  m = hashlib.md5()
  m.update(filepath)  
  return m.hexdigest()

def writePartsRecurse(msg):  
  """
  This module recursively parses all fields of multipart spam mail
  """
  while isinstance(msg.get_payload(),email.Message.Message):
    msg=msg.get_payload()
  
  if msg.is_multipart():
    for subMsg in msg.get_payload():
      writePartsRecurse(subMsg)
  else:
    file_name=msg.get_filename()
    content=msg.get_content_type()
    logging.critical("content type::::: %s" % content)
    logging.critical("file name::::: %s" % file_name)

    if msg.get_content_type() == 'text/plain':								# value of content-dispostion is None in this case
      mailFields['text'] = msg.get_payload(decode=True)							# decode says - if in base64, decode the value	

    elif msg.get_content_type() == 'text/html':								# value of content-dispostion is None in this case					
      mailFields['html'] = msg.get_payload(decode=True)

    elif msg['Content-Disposition'] != None and msg['Content-Disposition'].find('inline;') >= 0:	# if 'inline' file found
      mailFields['inlineFile'].append(msg.get_payload())
      mailFields['inlineFileName'].append(msg.get_filename())
      mailFields['inlineFileMd5'].append(md5Checksum((msg.get_payload()).decode('base64')))			## msg.get_payload is in base64, decode it before finding md5sum

    elif msg['Content-Disposition'] != None and msg['Content-Disposition'].find('attachment;') >= 0:	# if attachment found
      mailFields['attachmentFile'].append(msg.get_payload())
      mailFields['attachmentFileName'].append(msg.get_filename())
      mailFields['attachmentFileMd5'].append(md5Checksum((msg.get_payload()).decode('base64')))

    elif msg.get_filename() != None:											## Sometimes field "Content-Disposition" is missing, field "attachment" is missing but "file name" is there with binary content
      mailFields['attachmentFile'].append(msg.get_payload())
      mailFields['attachmentFileName'].append(msg.get_filename())
      mailFields['attachmentFileMd5'].append(md5Checksum((msg.get_payload()).decode('base64')))

    else:												# if nothing matched
      logging.critical("[-] --------- (Module ShivaParser.py) No match for text/html/content_type or Content-Disposition -----------------")

  return None  


def main(key, msgMailRequest, exeSql):
  """
  This function gets called from queueFilter.filter()
  """
  global mailFields
  mailFields = {'headers':'', 'to':'', 'from':'', 'subject':'', 'date':'', 'firstSeen':'', 'lastSeen':'', 'firstRelayed':'', 'lastRelayed':'', 'sourceIP':'', 'sensorID':'', 'text':'', 'html':'', 'inlineFileName':[], 'inlineFile':[], 'inlineFileMd5':[], 'attachmentFileName':[], 'attachmentFile':[], 'attachmentFileMd5':[], 'links':[], 'spam_id':''}

  try:
    mailFile=open(ShivaConfig.queuePath + key,"rb")
    p=email.Parser.Parser()
    msg=p.parse(mailFile)
    mailFile.close()
    
    ## Extracting whole header - not individual fields - Nov, 2012
    f = open(ShivaConfig.queuePath + key)
    msgmsg = email.message_from_file(f)
    pp = email.parser.HeaderParser()
    hh = pp.parsestr(msgmsg.as_string())
    
    headerString = ''
    for h in hh.items():
      headerString += str(h) + '\n'						# h is a tuple value. Converting to string to add a string to it
    mailFields['headers'] = headerString
    mailFields['headers'] = str(mailFields['headers']).replace("'", "")
    
  except IOError:
    logging.critical("[-] Error (Module ShivaMailParser.py) - could not open|write file %s \n" % key)
    ShivaConfig.errorHandling(key, msgMailRequest)
    return None

  try:
    try:	
      mailFields['to'] = msg['to'].replace("'", "")
    except:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'to' field %s" % key)
      logging.critical("to: %s", mailFields['to'])
      ShivaConfig.errorHandling(key, msgMailRequest)
      return None
    
    try:
      from_field = msg['from']
      
      if from_field != None:	
	regex_from = r'''([\w\-\.+]+@\w[\w\-]+\.+[\w\-]+)'''									# Just looking for mail id
	mailFields['from'] = re.findall (re.compile(regex_from), from_field)[0]
	mailFields['from'] = mailFields['from'].replace("'", "")
	mailFields['from'] = mailFields['from'].replace('"', '')
      else:
	logging.critical("[-] Info ShivaMailParser.py - From field has value None")
	pass
      
    except:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'from' field %s" % key)
      logging.critical("from: %s", mailFields['from'])
      ShivaConfig.errorHandling(key, msgMailRequest)
      return None 
    
    try:
      subject, encoding = decode_header(msg.get('subject'))[0]									# Seen cases of unicode. Function returns the encoding type if any
  
      if encoding == None:
	mailFields['subject'] = subject
	pass
      else:
	mailFields['subject'] = subject.decode(encoding)
	mailFields['subject'] = mailFields['subject'].encode('utf-8')								# Need to encode('utf-8') else won't be able to push into DB
  
      if msgMailRequest['subject'] != None:
	mailFields['subject'] = mailFields['subject'].replace("'", "")
	mailFields['subject'] = mailFields['subject'].replace('"', '')
      else:
	logging.critical("[-] Info ShivaMailParser.py - Subject field has value None")
	pass
    except:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'subject' field %s" % key)
      logging.critical("subject: %s", mailFields['subject'])
      ShivaConfig.errorHandling(key, msgMailRequest)
      return None
    
    try:
      mailFields['sourceIP'] = key.split("-")[-2]
      mailFields['sensorID'] = key.split("-")[-1]    
    except:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'sourceIP and sensorID' field %s" % key)
      ShivaConfig.errorHandling(key, msgMailRequest)
      return None
      
    try:
      writePartsRecurse(msg)
    except:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in writePartsRecurse function %s" % key)
      ShivaConfig.errorHandling(key, msgMailRequest)
      return None
    
    # remove single and double quotes from various fields, they break lamson server, this could be done in writePartsRecurse function itself
    try:
      if mailFields['text'] != None:
	mailFields['text'] = mailFields['text'].replace("'", "")
      if mailFields['html'] != None:
	mailFields['html'] = mailFields['html'].replace("'", "")
    except:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in 'text' and 'html' field %s" % key)
      logging.critical("text: %s", mailFields['text'])
      logging.critical("html: %s", mailFields['html'])
      ShivaConfig.errorHandling(key, msgMailRequest)
      return None
    
    try:
      mailFields['links'] = ShivaLinkParser.parser(mailFields['html'])
      mailFields['links'].extend(ShivaLinkParser.parser(mailFields['text']))
    except:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'links' field %s" % key)
      logging.critical("links: %s", mailFields['links'])
      ShivaConfig.errorHandling(key, msgMailRequest)
      return None
    
    # Timestamping when spam is parsed by our code; not the original time stamping
    mailFields['date'] =  datetime.date.today()
    mailFields['firstSeen'] =  datetime.datetime.now()
    mailFields['lastSeen'] =  datetime.datetime.now()
    mailFields['firstRelayed'] =  datetime.datetime.now()
    mailFields['lastRelayed'] =  datetime.datetime.now()
    
    spam_id = str(mailFields['from']) + str(mailFields['subject'])
    mailFields['spam_id'] = hashlib.md5(spam_id).hexdigest()
  
  except:
    logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing file %s" % key)
    ShivaConfig.errorHandling(key, msgMailRequest)
    return None
     
  # Call to ShivaMailRelayer.relay function which determines whether spam is new or old
  ShivaMailRelayer.relay(mailFields, key, msgMailRequest, exeSql)
  return None
