"""
This module accepts spam file name as parameter and returns all parsed fields as items of a dictionary
In current state, it's accepting spam file name as parameter, parsing all fields, saving in a dictionary and forwarding to another module

"""

import email.Message
import email.Parser
from email.header import decode_header
import os, sys, logging, re
import MySQLdb as mdb
import ShivaLinkParser, ShivaMailRelayer, ShivaConfig
import time, datetime
import hashlib								# Shiva - to calculate the md5 of attachment and inline files
import base64
import ssdeep
import lxml.html
import ShivaDecide

# Global dictionary to store parsed fields of spam
mailFields = {'headers':'', 'to':'', 'from':'', 'subject':'', 'date':'', 'firstSeen':'', 'lastSeen':'', 'firstRelayed':'', 'lastRelayed':'', 'sourceIP':'', 'sensorID':'', 'text':'', 'html':'', 'inlineFileName':[], 'inlineFile':[], 'inlineFileMd5':[], 'attachmentFileName':[], 'attachmentFile':[], 'attachmentFileMd5':[], 'links':[], 'spam_id':'', 'spamMd5':'', 'len':''}


randomText = """@Deprecation

In Solr 1.3, many classes were moved around. Although classes compiled against 1.2 will run in 1.3, updating class references is recommended.

Specifically:

    many classes from org.apache.util moved to org.apache.common.util

    many classes from org.apache.solr.request moved to org.apache.solr.common.params

    org.apache.solr.request.StandardRequestHandler moved to org.apache.solr.handler.StandardRequestHandler and is a subclass of org.apache.solr.handler.SearchHandler

    org.apache.solr.request.DisMaxRequestHandler moved to org.apache.solr.handler.DisMaxRequestHandler and deprecated in favor of adding 'defType=dismax' to StandardRequestHandler init params 

Solr1.3 (last edited 2009-09-20 22:04:51 by localhost SHIVA."""

def md5Checksum(filepath):
  m = hashlib.md5()
  
  m.update(filepath)  
  return m.hexdigest()


def getFuzzyHash():
  """
  This function returns hash generated using the ssdeep library.
  Hash is generated using the combination of mail's body + subject.
  Msg length is being checked because SSDEEP has some issues with comparing hashes
  of small spams. If spam's bosy is very less or non existent, we add our randomText to body.
  """
  if mailFields['html']:
    if len(mailFields['html']) < 60:
      data = mailFields['html'] + " " + mailFields['subject'] + randomText
      logging.info("Data is %s" % data)
    else:  
      data = mailFields['html'] + " " + mailFields['subject']
  else:
    if len(mailFields['text']) < 60:
      data = mailFields['text'] + " " + mailFields['subject'] + randomText
      logging.info("Data is %s" % data)
    else:  
      data = mailFields['text'] + " " + mailFields['subject']
  
  mailFields['len'] = len(data)
  return ssdeep.hash(data)
    
  

def fixPaddingforAttachments(payload):
  logging.critical("\t[+]Fixing Padding for Attachment if needed")
  logging.critical("\t\t[+]length of original payload: %s" % len(payload))
  payload = payload.rstrip()
  logging.critical("\t\t[+]length after striping whitespaces: %s" % len(payload))
  
  missing_padding = (4 - len(payload) % 4) % 4
  logging.critical("\t\t[+]missing padding: %s" % missing_padding)
  payload += '=' * missing_padding
              
  logging.critical("\t\t[+]New length after padding: %s" % len(payload))
  return payload
      


def writePartsRecurse(msg):  
  """
  This module recursively parses all fields of multipart spam mail
  """
  while isinstance(msg.get_payload(),email.Message.Message):
    msg=msg.get_payload()
  
  if msg.is_multipart():
    for subMsg in msg.get_payload():
      writePartsRecurse(subMsg)
  else:
    #file_name=msg.get_filename()
    content=msg.get_content_type()
    logging.critical("\t[+]Content type::::: %s" % content)

    logging.critical("\t[+]File name before decoding: %s" % msg.get_filename())
    file_name, encoding = decode_header(msg.get_filename())[0]					# Seen cases of unicode. Function returns the encoding type if any
    
    file_name = file_name.replace("'", "")	  
    if encoding == None:
      fileName = file_name
    else:
      fileName = file_name.decode(encoding)
      fileName = fileName.encode('utf-8')
    
    logging.critical("\t[+]File name after decoding: %s" % fileName)
	## The following first condition is to cover up when "content-type" field comes empty. By default parser takes it as text/plain, so need to take care of attachments    
    if msg.get_content_type() == 'text/plain' and msg['Content-Disposition'] == None:			# value of content-dispostion is None in this case
      mailFields['text'] = msg.get_payload(decode=True)							# decode says - if in base64, decode the value	
      #mailFields['text'] = msg.get_payload()
    elif msg.get_content_type() == 'text/html':								# value of content-dispostion is None in this case			
      mailFields['html'] = msg.get_payload(decode=True)
      #mailFields['html'] = msg.get_payload()
    elif msg['Content-Disposition'] != None and msg['Content-Disposition'].find('inline;') >= 0:	# if 'inline' file found
      logging.critical("Inside inline handling")
      payload = fixPaddingforAttachments(msg.get_payload())
                              
      mailFields['attachmentFile'].append(payload)
      mailFields['attachmentFileName'].append(fileName)
      mailFields['attachmentFileMd5'].append(md5Checksum((payload).decode('base64')))
    
    elif msg['Content-Disposition'] != None and msg['Content-Disposition'].find('attachment;') >= 0:	# if attachment found
      logging.critical("Inside Attachment handling")

      payload = fixPaddingforAttachments(msg.get_payload())
                              
      mailFields['attachmentFile'].append(payload)
      mailFields['attachmentFileName'].append(fileName)
      mailFields['attachmentFileMd5'].append(md5Checksum((payload).decode('base64')))

    elif msg.get_filename() != None:											## Sometimes field "Content-Disposition" is missing, field "attachment" is missing but "file name" is there with binary content
      payload = fixPaddingforAttachments(msg.get_payload())
                              
      mailFields['attachmentFile'].append(payload)
      mailFields['attachmentFileName'].append(fileName)
      mailFields['attachmentFileMd5'].append(md5Checksum((payload).decode('base64')))

    else:												# if nothing matched
      logging.critical("[-] --------- (Module ShivaParser.py) No match for text/html/content_type or Content-Disposition -----------------")
      #ShivaConfig.errorHandling(key, msgMailRequest)
      #return None
 
  return None


def main(key, msgMailRequest, exeSql):
  """
  This function gets called from queueFilter.filter()
  """
  logging.critical("inside main module")
  global mailFields
  #mailFields = {'to':'', 'from':'', 'subject':'', 'date':'', 'text':'', 'html':'', 'inlineFileName':[], 'inlineFile':[], 'inlineFileMd5':[], 'attachmentFileName':[], 'attachmentFile':[], 'attachmentFileMd5':[], 'links':[]}
  mailFields = {'headers':'', 'to':'', 'from':'', 'subject':'', 'date':'', 'firstSeen':'', 'lastSeen':'', 'firstRelayed':'', 'lastRelayed':'', 'sourceIP':'', 'sensorID':'', 'text':'', 'html':'', 'inlineFileName':[], 'inlineFile':[], 'inlineFileMd5':[], 'attachmentFileName':[], 'attachmentFile':[], 'attachmentFileMd5':[], 'links':[], 'spam_id':'', 'len':'', 'spamMd5':''}

  

  # 'key' contains the name of spam file retrieved from queue
  try:
    mailFile=open(ShivaConfig.queuePath + key,"rb")  
    garbledData = mailFile.read()
    match = re.search("Received: from", garbledData)
    
    if match:
	mailFile.close()
	goodData = open(ShivaConfig.queuePath + key, "wb")
	goodData.write(garbledData[match.start():])
	goodData.close()
	mailFile=open(ShivaConfig.queuePath + key,"rb")
	
    else:	
      logging.critical("\n\t[+] 'Received: from' string not found - Inserting it")
      mailFile.close()
      goodData = open(ShivaConfig.queuePath + key,"wb")
      goodData.write("Received: from ShivaVT-applied-fix-to-broken-header.com\n" + garbledData)
      goodData.close()
      mailFile=open(ShivaConfig.queuePath + key,"rb")
	
    p=email.Parser.Parser()
    msg=p.parse(mailFile)
    mailFile.close()
    

    f = open(ShivaConfig.queuePath + key)
    msgmsg = email.message_from_file(f)
    pp = email.parser.HeaderParser()
    hh = pp.parsestr(msgmsg.as_string())
    
    headerString = ''
    for h in hh.items():
      headerString += str(h) + '\n'						# h is a tuple value. Converting to string to add a string to it
    mailFields['headers'] = headerString
    mailFields['headers'] = str(mailFields['headers']).replace("'", "")
    
  except Exception, e:   
    logging.critical("[-] Error (Module ShivaMailParser.py) - could not open|write file %s \n" % key)
    ShivaConfig.errorHandling(key, msgMailRequest, "[-] Error (Module ShivaMailParser.py) - could not open|write file %s %s \n" % (key, e))
    return None

  try:
    # filling up basic fields of dictionary, rest get their values only after reverse parsing of multipart spam mail
    try:	
      # "to" field - considered it won't be in unicode, else write code to handle it
      logging.critical("msg['to']: %s", msg['to'])
      if msg['to'] != None:
	mailFields['to'] = msg['to'].replace("'", "")
      else:
	logging.critical("[-] Info ShivaMailParser.py - To field has value None")
	mailFields['to'] = "-"
      
    except Exception, e:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'to' field %s" % key)
      logging.critical("to: %s", msg['to'])
      ShivaConfig.errorHandling(key, msgMailRequest, "[-] Error (Module ShivaMailParser.py) - some issue in parsing 'to' field %s %s \n" % (key, e))
      return None
    
    try:
      from_field = msg['from']
      logging.critical("From field before decoding: %s" % from_field)
      # "from" field - could be normal or unicode, but we are stipping of everything but just the mail id
      from_field, encoding = decode_header(msg.get('from'))[0]								# It failed for a case and output was just a double quote
      logging.critical("from: %s encoding: %s" % (from_field, encoding))
      
      if from_field != None:
	if encoding == None:
	  mailFields['from'] = from_field
	  mailFields['from'] = mailFields['from'].replace("'", "")
	  mailFields['from'] = mailFields['from'].replace('"', '')
	  logging.critical("From Field had no encoding: %s" % mailFields['from'])
	
	else:
	  try:
	    logging.critical("From Field is Encoded")
	  
	  
	    regex_from = r'''([\w\-\.+]+@\w[\w\-]+\.+[\w\-]+)'''									# Just looking for mail id
	    mailFields['from'] = re.findall (re.compile(regex_from), msg['from'])[0]
	    mailFields['from'] = mailFields['from'].replace("'", "")
	    mailFields['from'] = mailFields['from'].replace('"', '')
	    logging.critical("From Field had encoding: %s" % mailFields['from'])
	  except Exception, e:
	    mailFields['from'] = from_field
	    mailFields['from'] = mailFields['from'].replace("'", "")
	    mailFields['from'] = mailFields['from'].replace('"', '')
	    logging.critical("[-] Warning: From Field had encoding, but regex got issue parsing it - pushing following into DB: %s" % mailFields['from'])
	    ShivaConfig.errorHandling(key, msgMailRequest, "[-] Warning (Module ShivaMailParser.py) 'From' Field had encoding, but regex got issue parsing it %s %s \n" % (key, e))
	    
	
      else:
	logging.critical("[-] Info ShivaMailParser.py - From field has value None")
	mailFields['from'] = "-"

    except Exception, e:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'from' field %s -- %s" % (key, e.args))
      logging.critical("from: %s", msg['from'])
      ShivaConfig.errorHandling(key, msgMailRequest, "[-] Error (Module ShivaMailParser.py) - some issue in parsing 'from' field %s %s \n" % (key, e))
      return None
    
    try:
      subject, encoding = decode_header(msg.get('subject'))[0]									# Seen cases of unicode. Function returns the encoding type if any
  
      if encoding == None:
	mailFields['subject'] = subject
	pass
      else:
	mailFields['subject'] = subject.decode(encoding)
	mailFields['subject'] = mailFields['subject'].encode('utf-8')								# Need to encode('utf-8') else won't be able to push into DB
  
      if mailFields['subject'] != None:
	mailFields['subject'] = mailFields['subject'].replace("'", "")
	mailFields['subject'] = mailFields['subject'].replace('"', '')

      else:
	logging.critical("[-] Info ShivaMailParser.py - Subject field has value None")
	pass


    except Exception, e:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'subject' field %s" % key)
      logging.critical("subject: %s", mailFields['subject'])
      ShivaConfig.errorHandling(key, msgMailRequest, "[-] Error (Module ShivaMailParser.py) - some issue in parsing 'subject' field %s %s \n" % (key, e))
      return None
    
    try:
      pass												# In VT mails, hard to get sourceIP, some mails doesn't have it at all

      mailFields['sourceIP'] = key.split("-")[-2]
      mailFields['sensorID'] = key.split("-")[-1]    
    except Exception, e:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'sourceIP and sensorID' field %s" % key)

      ShivaConfig.errorHandling(key, msgMailRequest, "[-] Error (Module ShivaMailParser.py) - some issue in parsing 'sourceIP and sensorID' fields %s %s \n" % (key, e))
      return None

      
    try:
      
      ## call function to obtain rest of the fields - it handles multipart mails as well
      writePartsRecurse(msg)
    except Exception, e:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in writePartsRecurse function %s -- %s" % (key, e.args))
      ShivaConfig.errorHandling(key, msgMailRequest, "[-] Error (Module ShivaMailParser.py) - some issue in writePartsRecurse function %s %s \n" % (key, e))
      return None
    
    # remove single and double quotes from various fields, they break lamson server, this could be done in writePartsRecurse function itself
    try:
      if mailFields['text'] != None:
	mailFields['text'] = mailFields['text'].replace("'", "")

      #if msgMailRequest['html'] != None:
      if mailFields['html'] != None:
	#logging.critical("replacing single quotes in HTML")
	mailFields['html'] = mailFields['html'].replace("'", "")
   
 except Exception, e:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in 'text' and 'html' field %s" % key)
      logging.critical("text: %s", mailFields['text'])
      logging.critical("html: %s", mailFields['html'])
      #ShivaConfig.errorHandling(key, msgMailRequest)
      ShivaConfig.errorHandling(key, msgMailRequest, "[-] Error (Module ShivaMailParser.py) - some issue in 'text' and 'html' field %s %s \n" % (key, e))
      return None
    
    # parse different parts of spam (text, html, inline) and hunt for URLs
    try:
      #logging.critical("parsing field LINKS")
      mailFields['links'] = ShivaLinkParser.parser(mailFields['html'])
      mailFields['links'].extend(ShivaLinkParser.parser(mailFields['text']))
    except Exception, e:
      logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing 'links' field %s" % key)
      logging.critical("links: %s", mailFields['links'])
      #ShivaConfig.errorHandling(key, msgMailRequest)
      ShivaConfig.errorHandling(key, msgMailRequest, "[-] Error (Module ShivaMailParser.py) - some issue in parsing 'links' field %s %s \n" % (key, e))
      return None
    
    # Timestamping when spam is parsed by our code; not the original time stamping
    mailFields['date'] =  datetime.date.today()
    mailFields['firstSeen'] =  datetime.datetime.now()
    mailFields['lastSeen'] =  datetime.datetime.now()
    mailFields['firstRelayed'] =  datetime.datetime.now()
    mailFields['lastRelayed'] =  datetime.datetime.now()
      
    try:
      mailFields['spam_id'] = getFuzzyHash()  
      logging.info("Spam ID is %s", mailFields["spam_id"])  
    except Exception, e:
      logging.critical("[-]Error (Module ShivaMailParser.py) - occured while calculating fuzzy hash for spam id. Exception is %s", e)
 
    if mailFields['html']:
      mailFields['spamMd5'] = md5Checksum(mailFields['subject'] + mailFields['html'])
    elif mailFields['text']:
      mailFields['spamMd5'] = md5Checksum(mailFields['subject'] + mailFields['text'])
    else:
      mailFields['spamMd5'] = md5Checksum(mailFields['subject'])

    
  except Exception, e:
    logging.critical("[-] Error (Module ShivaMailParser.py) - some issue in parsing file %s exception is: %s" % (key, e))
    ShivaConfig.errorHandling(key, msgMailRequest, "[-] Error (Module ShivaMailParser.py) - some issue in parsing file %s %s \n" % (key, e))
    return None
  
  ShivaDecide.decide(mailFields, key, exeSql, msgMailRequest)
  
  return None
