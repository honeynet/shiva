 
#This file is no longer used in SHIVA.

"""
This module determines whether to relay or not

Combo = From + Subject + Date, (or combination of any fields) and is determined in ShivaMailParser module

Any new spam would fall under two broad categories:
  1. New Combo
  2. Old Combo

If New Combo:
> Dump spam into DB (spam table)
> Increase Total Counter of spams in spamPot.spam.totalCounter
> Make decision on basis of "Relay Counter (RC) for the day" whether to relay or not. e.g if RC<100 -> Relay, else don't relay. Relay counter = Sum (individual counters in relay table)
> Increment individual counter IC in relay table if relayed
> Remove message from QueueReceiver

If Old Combo:
> Check if any new attachment has come
> If yes - save that attachment, if no - don't save
> Check if new links have come. If yes, save them, else don't
> In both cases, increase Total Counter (TC) in spamPot.spam.totalCounter
> Make decision on basis of "Relay Counter" (RC) and Individual Counter (IC) - if (IC < 10 && RC < 100) - Relay, if [(IC = 10 && RC < 100) || if (IC < 10 && RC = 100)] - Don't relay
> If relayed - increment IC in relay table
> Remove message from QueueReceiver
"""
import server
import os, sys, logging
import MySQLdb as mdb
import ShivaConfig, ShivaTackleQueue, ShivaNewSpam, ShivaOldSpam
import time, datetime
import ssdeep

#mailFields = {'to':'', 'from':'', 'subject':'', 'date':'', 'text':'', 'html':'', 'inlineFileName':[], 'inlineFile':[], 'inlineFileMd5':[], 'attachmentFileName':[], 'attachmentFile':[], 'attachmentFileMd5':[], 'links':[]}

queuePath = ShivaConfig.queuePath
#dataBase = "spamPot09252012"

def relay(mailFields, key, msgMailRequest, exeSql):
  """
  It does the decision making part - which spam to relay, which attachment to save, client notifications etc.
  We check for our magic string in the mail body to find if the mail is having our randomText. We need to keep
  threshold very high in that case.
  """
  ratio = 0
  status = 0							# status = 0 (new combo), i.e. "from" + "subject" + "date" combo is not in DB, so consider it as new combo and relay if counters allow
								# status = 1 (old combo), i.e. "from" + "subject" + "date" combo is already there but check if new md5 attachment has come. If yes, save it
  hashToBeChecked = str(mailFields['spam_id'])
    
  if mailFields['html'][-6:-0] is "SHIVA" or mailFields['html'][-6:-0] is "SHIVA":
    logging.debug("[-]In ShivaMailRelayer: This spam contains magic string.")
    threshold = 90
  elif mailFields['text']:
    threshold = 75			#threshhold is in test stage
  else:
    threshold = 85
       
  # Retrieve existing combos from DB to get checked against combo of spam under analysis
  #checkData = "SELECT spamPot.spam.from, spamPot.spam.subject, spamPot.spam.firstSeen FROM spamPot.spam"
  #checkData = "SELECT spamPot.spam.comboMD5 FROM spamPot.spam"
  #checkData = "SELECT spamPot.spam.id FROM spamPot.spam WHERE spamPot.spam.id = '"+ str(mailFields['spam_id'])+"'" - 09262012
  #checkData = "SELECT spamPot09252012.spam.id FROM spamPot09252012.spam WHERE spamPot09252012.spam.id = '"+ str(mailFields['spam_id'])+"'"
  #checkData = "SELECT spam.id FROM spam WHERE spam.id = '"+ str(mailFields['spam_id'])+"'"
  checkData = "SELECT spam.id FROM spam"
  logging.info("[+] Inside ShivaMailRelayer.py ")
  #logging.critical("Control reaches here")
  #logging.critical("DB Name: %s" % ShivaConfig.dataBaseName)
  #checkData = "SELECT %s"  % (ShivaConfig.dataBaseName) + "." + "spam.id FROM spamPot09252012.spam WHERE spamPot09252012.spam.id = '"+ str(mailFields['spam_id'])+"'"
  #logging.critical("\n\n\t\tSQL Query: %s" % checkData)
  #sys.exit(1)
    
  try:
    logging.info("comparing hashes")
    exeSql.execute(checkData)
    rows = exeSql.fetchall()
    while True:
      if len(rows) >= 1:
        for spamHash in rows:
	  logging.info("SpamHash is %s " %(str(spamHash[0])))
          ratio = ssdeep.compare(hashToBeChecked, str(spamHash[0]))
          logging.info("[+](Module: ShivaMailRelayer.py) Ratio is: %d" % ratio) 
          if ratio >= threshold:
            matchedHash = str(spamHash)
            status = 1
            break
        break
      else:
	break
    

    '''
    #print "exiting......b0nd"
    #sys.exit(1)
    if len(exeSql.fetchall()) >= 1:
      status = 1
    

    exeSql.execute(checkData)
    while(1):
      row = exeSql.fetchone()
      
      #logging.critical("type of row[0]: %s", type(row[0].encode('utf-8')))
      #logging.critical("type of row[1]: %s", type(row[1]))
      if row == None:						# After reading last entry of DB, row returns None
	break
      #elif mailFields['from'] == row[0].encode('utf-8') and mailFields['subject'] == row[1].encode('utf-8') and str(datetime.date.today()) == str(row[2]).split(" ")[0]:	# MySQL from and subject are utf8 collated, so all data retrieved of type unicode. Need to convert before comaprision
      elif str(mailFields['comboMD5']) == row[0]:
	status = 1						# i.e, recent spams "from" + "subject" + "date" combo is already in DB	
	break
      else:							# continue the loop if no match yet
	pass
    
    exeSql.execute(checkData)
    rows = exeSql.fetchall()
    
    for row in rows:
       if str(mailFields['comboMD5']) == row[0]:
	 status = 1
	 break
       else:
	 pass
      #str(mailFields['comboMD5']) == row[1]:
    
    #for row in rows:
     #print "%s, %s" % (row[0], row[1])
   #print "Number of rows returned: %d" % cursor.rowcount
    '''
  except mdb.Error, e:
    logging.critical("[-] Error (ShivaMailRelayer - retriving combos from DB) - %d: %s" % (e.args[0], e.args[1]))
    #print "exiting1......b0nd"
    #sys.exit(1)
    #ShivaConfig.errorHandling(key, msgMailRequest)
    ShivaConfig.errorHandling(key, msgMailRequest, "[-] Error (Module ShivaMailRelayer.py) - retriving combos from DB %s %s \n" % (key, e))
    return None
  
  # Old Combo
  # Step 1: check if new attachment(s) has/have come with old combo
  # Step 2: if yes, save attachment(s), retrive spamPot.spam.totalCounter for combo and increase it by 1
  # Step 3: if no, don't save attachment(s), retrive spamPot.spam.totalCounter for combo and increase it by 1
  # Step 4: put relay test cases:
  #	  : if individual_relayed_today < 10 && totalRelayed_today < 100 -> relay, retrive individual_relayed_today & totalRelayed and increment by 1
  #	  : if (individual_relayed_today = 10 && totalRelayed_today < 100 ) or (individual_relayed_today < 10 && totalRelayed_today = 100) - don't relay
  # Step 5: remove message from queue
  
  if status == 1:						# i.e. it's old combo
    logging.critical("status = 1, i.e. Old Combo - found in DB")
    ShivaOldSpam.pushIntoDB(mailFields, key, msgMailRequest, exeSql, matchedHash)
      
  # status = 0, i.e., combo not found in DB, so push data in it
  
  # New Combo:
  # Step 1: push data into DB
  # Step 2: initialize totalCounter for new combo
  # Step 3: compare with total spams relayed for the day. 
  # Step 4: if haven't reached limit yet, relay spam, initialize relayCounter and totalRelayed, and remove message from queue
  # Step 5: if limit for the day is reached, don't relay, but remove message from queue
  else:
    logging.critical("status = 0, i.e. New Combo - from and subject not found in DB")
    ShivaNewSpam.pushIntoDB(mailFields, key, msgMailRequest, exeSql)   
    
  #exeSql.close()  
