 
"""
This module determines whether to relay or not

Combo = From + Subject + Date, (or combination of any fields) and is determined in ShivaMailParser module

Any new spam would fall under two broad categories:
  1. New Combo
  2. Old Combo

If New Combo:
> Dump spam into DB (spam table)
> Increase Total Counter of spams in spamPot.spam.totalCounter
> Make decision on basis of "Relay Counter (RC) for the day" whether to relay or not. e.g if RC<100 -> Relay, else don't relay. Relay counter = Sum (individual counters in relay table)
> Increment individual counter IC in relay table if relayed
> Remove message from QueueReceiver

If Old Combo:
> Check if any new attachment has come
> If yes - save that attachment, if no - don't save
> Check if new links have come. If yes, save them, else don't
> In both cases, increase Total Counter (TC) in spamPot.spam.totalCounter
> Make decision on basis of "Relay Counter" (RC) and Individual Counter (IC) - if (IC < 10 && RC < 100) - Relay, if [(IC = 10 && RC < 100) || if (IC < 10 && RC = 100)] - Don't relay
> If relayed - increment IC in relay table
> Remove message from QueueReceiver
"""
import server
import os, sys, logging
import MySQLdb as mdb
import ShivaConfig, ShivaTackleQueue, ShivaNewSpam, ShivaOldSpam
import time, datetime

#mailFields = {'to':'', 'from':'', 'subject':'', 'date':'', 'text':'', 'html':'', 'inlineFileName':[], 'inlineFile':[], 'inlineFileMd5':[], 'attachmentFileName':[], 'attachmentFile':[], 'attachmentFileMd5':[], 'links':[]}

queuePath = ShivaConfig.queuePath
#dataBase = "spamPot09252012"

def relay(mailFields, key, msgMailRequest, exeSql):
  """
  It does the decision making part - which spam to relay, which attachment to save, client notifications etc.
  """
  
  status = 0							# status = 0 (new combo), i.e. "from" + "subject" + "date" combo is not in DB, so consider it as new combo and relay if counters allow
								# status = 1 (old combo), i.e. "from" + "subject" + "date" combo is already there but check if new md5 attachment has come. If yes, save it
  
  # Retrieve existing combos from DB to get checked against combo of spam under analysis
  #checkData = "SELECT spamPot.spam.from, spamPot.spam.subject, spamPot.spam.firstSeen FROM spamPot.spam"
  #checkData = "SELECT spamPot.spam.comboMD5 FROM spamPot.spam"
  #checkData = "SELECT spamPot.spam.id FROM spamPot.spam WHERE spamPot.spam.id = '"+ str(mailFields['spam_id'])+"'" - 09262012
  #checkData = "SELECT spamPot09252012.spam.id FROM spamPot09252012.spam WHERE spamPot09252012.spam.id = '"+ str(mailFields['spam_id'])+"'"
  checkData = "SELECT spam.id FROM spam WHERE spam.id = '"+ str(mailFields['spam_id'])+"'"
  
  #logging.critical("Control reaches here")
  #logging.critical("DB Name: %s" % ShivaConfig.dataBaseName)
  #checkData = "SELECT %s"  % (ShivaConfig.dataBaseName) + "." + "spam.id FROM spamPot09252012.spam WHERE spamPot09252012.spam.id = '"+ str(mailFields['spam_id'])+"'"
  #logging.critical("\n\n\t\tSQL Query: %s" % checkData)
  #sys.exit(1)
    
  try:
    exeSql.execute(checkData)
    #print "exiting......b0nd"
    #sys.exit(1)
    if len(exeSql.fetchall()) >= 1:
      status = 1
    
    '''
    exeSql.execute(checkData)
    while(1):
      row = exeSql.fetchone()
      
      #logging.critical("type of row[0]: %s", type(row[0].encode('utf-8')))
      #logging.critical("type of row[1]: %s", type(row[1]))
      if row == None:						# After reading last entry of DB, row returns None
	break
      #elif mailFields['from'] == row[0].encode('utf-8') and mailFields['subject'] == row[1].encode('utf-8') and str(datetime.date.today()) == str(row[2]).split(" ")[0]:	# MySQL from and subject are utf8 collated, so all data retrieved of type unicode. Need to convert before comaprision
      elif str(mailFields['comboMD5']) == row[0]:
	status = 1						# i.e, recent spams "from" + "subject" + "date" combo is already in DB	
	break
      else:							# continue the loop if no match yet
	pass
    
    exeSql.execute(checkData)
    rows = exeSql.fetchall()
    
    for row in rows:
       if str(mailFields['comboMD5']) == row[0]:
	 status = 1
	 break
       else:
	 pass
      #str(mailFields['comboMD5']) == row[1]:
    
    #for row in rows:
     #print "%s, %s" % (row[0], row[1])
   #print "Number of rows returned: %d" % cursor.rowcount
    '''
  except mdb.Error, e:
    logging.critical("[-] Error (ShivaMailRelayer - retriving combos from DB) - %d: %s" % (e.args[0], e.args[1]))
    #print "exiting1......b0nd"
    #sys.exit(1)
    ShivaConfig.errorHandling(key, msgMailRequest)
    return None
  
  # Old Combo
  # Step 1: check if new attachment(s) has/have come with old combo
  # Step 2: if yes, save attachment(s), retrive spamPot.spam.totalCounter for combo and increase it by 1
  # Step 3: if no, don't save attachment(s), retrive spamPot.spam.totalCounter for combo and increase it by 1
  # Step 4: put relay test cases:
  #	  : if individual_relayed_today < 10 && totalRelayed_today < 100 -> relay, retrive individual_relayed_today & totalRelayed and increment by 1
  #	  : if (individual_relayed_today = 10 && totalRelayed_today < 100 ) or (individual_relayed_today < 10 && totalRelayed_today = 100) - don't relay
  # Step 5: remove message from queue
  
  if status == 1:						# i.e. it's old combo
    logging.critical("status = 1, i.e. Old Combo - found in DB")
    ShivaOldSpam.pushIntoDB(mailFields, key, msgMailRequest, exeSql)
      
  # status = 0, i.e., combo not found in DB, so push data in it
  
  # New Combo:
  # Step 1: push data into DB
  # Step 2: initialize totalCounter for new combo
  # Step 3: compare with total spams relayed for the day. 
  # Step 4: if haven't reached limit yet, relay spam, initialize relayCounter and totalRelayed, and remove message from queue
  # Step 5: if limit for the day is reached, don't relay, but remove message from queue
  else:
    logging.critical("status = 0, i.e. New Combo - from and subject not found in DB")
    ShivaNewSpam.pushIntoDB(mailFields, key, msgMailRequest, exeSql)   
    
  #exeSql.close()  